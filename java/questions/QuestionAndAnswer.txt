为什么会重排序
    提高编译器和处理器的执行性能
为什么要禁止重排序
    在单线程的情况下时没有问题的
    在多线程的情况下，重排序会导致内存可见性的问题，
    例子：单例模式的双重检查，正常创建对象步骤，1 申请内存空间 2 初始化对象变量 3 变量指向内存空间，指定重拍可能会存在132的结果，线程A完成13之后，线程B去取的时候就发现对象不是空，但是没有初始化对象变量导致出错
    比如定义一个全局变量，线程A和B同时操作该变量会出现不可预测的结果，导致出错
禁止重排序的方法
    volatile：内存屏障，保证volatile前面的所有执行完，后面的指令都不执行。所有变更强制刷新到主存。


锁升级：https://zhuanlan.zhihu.com/p/172161661
synchronized锁有四种状态，无锁，偏向锁，轻量级锁，重量级锁
偏向锁，线程在java对象头和栈帧记录偏向锁的thread_id,在线程获取锁的时候判断thread_id是否相同，相同直接获取锁，不同判断偏向锁的thread_id对应的线程是否存活，如果不存活就重新标记新的thread_id,如果存活说明存在锁竞争，升级成轻量级锁
轻量级锁：自旋+cas方式，自旋次数过多，会升级成重量级锁
重量级锁：通过对象内部monitor实现，依赖操作系统底层，需要从用户态切换到内核态，成本高。

锁优化：（1）并发高考虑关闭自旋锁（2）锁消除（3）锁粗化，相邻同步块是使用同一个锁实例，编译器会合并成一个大的同步块，避免反复申请释放（4）减少锁粒度，参考ConcurentHashMap的分段锁到1.8之后的每个数组对象列表上。

Synchronized原理
可重入，不可中断。锁代码块和方法，标志位，代码块monitorenter monitorexit。方法ACC_SYNCHRONIZED标识

Lock和Synchronized
一个是关键字，基于jvm；一个是接口
一个自动加锁自动释放（异常也会解锁）；一个执行前加锁，执行完解锁
sync线程A获得锁后阻塞，线程B会一直等待；Lock可以不一定一直等待
sync无法获取锁状态；lock可以判断是否获取到锁
sync可重入，不可中断，非公平；lock可重入，可中断，可以公平和非公平
sync的局限性：其他线程只能等待直到持有锁的线程执行完释放锁；非公平锁使一些线程处于饥饿状态；多个线程都只是进行读操作时，线程之间也会发生冲突
lock：有限等待（tryLock），可中断，可以判断获取锁。

aqs（摘录）
维护一个双向队列，也就是Sync队列，初始情况下队列为空，每个线程在尝试获取锁之前都会创建一个代表自己的结点并入队，
第一个结点入队时队列为空，此时会额外创建一个头结点，使得第一个入队的线程结点为头结点的后继，对于之后入队的结点，添加到队列尾。所有结点在无限循环中不断尝试获取锁，
成功获取锁的条件是线程结点为头结点的后继并且tryAcquire方法返回true（由子类实现该方法），获取成功后会更新自己为头结点，所以除了初始化队列时创建的结点外，所有头结点都表示当前持有锁的线程结点，
如果获取失败会更新自己的前驱状态为SIGNAL，表示前驱在释放锁的时候需要唤醒后继，之后调用LockSupport.park陷入阻塞。
当持有锁的线程释放锁时，如果头结点的状态为SIGNAL或者PROPAGATE（该状态的作用见setHeadAndPropagate方法），会更新自己的状态为0（表示该结点已经没用了），并唤醒后继结点，后继结点从阻塞中被唤醒并重新开始循环尝试获取锁，成功后更新自己为头结点。

ReentrantLock
通过SQA的独占锁和state字段（加锁次数），如果state设置为1后，设置自己为exclusiveOwnerThread，加锁递增，释放递减。
CountDownLatch
闭锁可以初始化一个数量，所有在该闭锁上调用await方法的线程都会阻塞直到该闭锁上的countDown方法被调用指定次数，闭锁只能使用一次。
在指定了一个countDown的次数，线程在调用await方法的时候都会判断state是否为0，每次在调用countDown方法都是执行releaseShared的方法降状态减1，减到0的时候会先tryreleaseShare判断是否真的执行释放，返回true执行doreleaseshared，唤醒头节点的后继。
Semaphore
可以控制多线程下资源的访问数量，流量控制并发。

类加载过程

starter

GC
    回收算法
    垃圾回收器
        G1
        CMS
    GC root
        虚拟机栈（栈帧中本地变量表）中的引用的对象
        方法区中类静态属性引用的对象
        方法区中常量引用的对象
        本地方法中JNI引用的对象
    调优
        jstat -gc  GC情况
        jstack -l [进程 ID] > jstack.log  线程死锁，CPU占用过高
        jmap -dump 内存泄漏，溢出


mysql
索引失效
    1 如何MySQL优化器认为全表扫描比使用索引更快，则不使用索引，如表数据很少，考虑到行数和回表的代价，MySQL可能不使用索引
    2 用or分隔开的条件，如果or前的条件中的列有索引，而后面的列没有索引，那么涉及到的索引都不会被用到，例如：select * from table_name where key1='a' or key2='b'，如果在key1上有索引而在key2上没有索引，则该查询不会走索引
    3 不符合最左前缀原则不使用索引
    4 如果like是以'%'开始的，则该列上的索引不会被使用
    5 如果列为字符串，则where条件中必须将字符常量值加引号，否则即使该列上存在索引，也不会被使用。例如：select * from table_name where key1 = 1，如果key1列保存的是字符串，即使key1上有索引，也不会被使用
    6 HERE字句的查询条件里有不等于号（WHERE column != ...）或<>操作符，导致匹配的行数过多，如果select的列需要回表才能获取到，则优化器会考虑回表的时间，不使用索引，如果不需要回表，则会使用索引
    7 where语句的等号左边进行函数、算术运算或其他表达式运算时，索引无效
    8 当使用联合索引时，如果对某个列使用了范围查找，则该列右边的索引都无法使用
B树和B+树
    区别：
        1：B+树非叶子节点的关键字只起到索引作用，实际的数据存储在叶子节点，B树的非叶子节点也存储数据
        2：B树在找到具体的数值以后，则结束，而B+树则需要通过索引找到叶子结点中的数据才结束，也就是说B+树的搜索过程中走了一条从根结点到叶子结点的路径，查询过程是稳定的
    为什么使用B+树
        存储结构：B+树的磁盘读取代价低：B+树的内部节点没有指向关键字具体信息的指针，换句话说，即分支节点没有存储数据，因此其内部节点相对B树更小。如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读内存中的需要查找的关键字也就越多，相对来说IO读写次数也就降低了
        查找方式：B+树便于范围查找：由于B+树的数据都存储在叶子节点上，分支节点均为索引，方便扫库，只需扫一遍叶子即可。但是B树在分支节点上都保存着数据，要找到具体的顺序数据，需要执行一次中序遍历来查找。所以B+树更加适合范围查询的情况，在解决磁盘IO性能的同时解决了B树元素遍历效率低下的问题
    查询优化
        尽量使用覆盖索引，减少索引树的搜索次数
        使用order by语句时需要考虑使用可以通过索引直接实现排序
        避免使用select *，只select需要的列
        小表驱动大表查询
        可以用子查询代替join，因为使用join时MySQL不会创建临时表
        对于分页查询，如果直接使用limit M, N，并且无法使用覆盖索引，则MySQL会查询扫描所有的M行和M行之后的N行，每一行都会回表，针对这种查询，可以先查询到需要的行的id，再根据id获得结果，避免不必要的回表
        除非必须要去重，否则最好使用union all而不要用union，如果没有all，则MySQL会添加distinct，导致需要对临时表做唯一性检查，代码很高
    锁
        共享锁
        排他锁
        行锁
        表锁
        间隙锁
        临键锁