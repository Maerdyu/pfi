
# 1.运行时数据区域

- 程序计数器
- 虚拟机栈
- 本地方法栈
- 堆
- 方法区

## 程序计数器
- 线程私有
- 唯一一个没有OutOfMemoryError的区域

### 虚拟机栈
- 线程私有
- 每个Java方法执行的时候都会创建一个栈帧
> 栈帧包括 局部变量表、操作数栈、动态链接、方法出口等。 局部变量表 就包括了基本类型和引用类型

## 本地方法栈
- 线程私有
- 执行Native方法

## Java堆
- 线程共享
- 存放对象实例的空间
> 随着JIT编译器的发展，逃逸技术分析成熟，标量替换和栈上分配技术将导致所有对象都分配在堆上不那么绝对
- 垃圾回收的主战场
> 根据垃圾回收的分代收集法 可分为新生代和老年代。新生代又可以细分为 eden, from survivor, to survivor
- TLAB(Thread Local Allocation Buffer)
> 根据内存分配划分，多个线程可以分配私有的缓存区，用来解决并发创建对象问题

## 方法区
- 线程共享
- 元空间，包括类信息，常量，静态变量，即时编译器编译的代码
- 运行常量池
> 运行常量池用于存放编译器生成的各种字面量和符号应用，同时也具备动态性，比如String的intern方法

## 直接内存
- NIO基于通道和Buffer的I/O方式，使用Native方法分配堆外内存

# 2.对象
- 对象的创建
- 对象内存布局
- 对象的访问定位

## 对象的创建
> 对象创建的几种方式？克隆、反序列化...
- 判断类是否加载
- 分配内存
> 分配空间的时候有两种，一种是碰撞指针，这种是对于内存规整的情况，需要垃圾回收具有压缩整理功能。第二种是空闲列表，根据列表分配一个内存足够的。

> 并发创建对象的问题有两种办法，一种是cas加失败重试，另一种是TLAB的方式，只要分配线程独享的缓存时加锁就可以了
- 置零
- 设置对象头
> 对象头包括 hashCode,gc分代，锁状态，锁标识等
- 执行init

## 对象的内存布局
- 对象头
- 实例数据
- 对齐填充

## 对象的访问定位
- 句柄访问
- 直接指针访问