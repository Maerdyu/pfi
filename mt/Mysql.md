# undolog redolog binlog rowlog
- undolog用于事务的回滚，同时和readview组成mvcc
- 每条记录都会有两个额外字段，一个是事务ID，另一个是rollback point指向上一个历史记录，所以每个记录的不同版本事务组成一个单链表
- redolog是innodb引擎层实现一种WAL方式，write ahead log，redolog是固定大小的循环写方式，这是一种顺序写的方式，比直接刷到磁盘速度快。
- redolog binlog是二阶段提交的，redolog先prepare 然后写binlog,最后redolog提交，实现了一种crash safe。
- rowlog 主要是在执行online ddl 的时候，记录源表在数据复制阶段新增的操作，这时候只有在创建临时表和追平数据的时候有MDL

# 索引
- mysql从磁盘加载到内存是按照一页一页加载的，默认一页16KB，所以B+每个节点都能保存16KB的数据，索引字段越小，保存的数据就越多。
- 存储的数据结构是B+数，特点的就是所有的数据数据节点都在叶子节点，每个节点之间是双向链表，节点内是单链表
- 主键索引，普通索引，唯一索引
- 普通索引和唯一索引的区别？在查询上，唯一索引比普通索引少一次遍历。在更新上，如果对应的数据页加载到内存中没有区别，如果没有加载到内存，普通索引会在changeBuffer中记录操作，
等到下次内存页加载的时候合并，而唯一索引需要每次都把数据页加载到内存中，速度比较慢，如果更新之后还有查询动作，也没有什么区别。在可重复性读隔离级别的快照读并且等值查询的是唯一索引会
把临键降级成行锁，普通索引会降级成间隙锁
- 索引的几个原则，1. 索引覆盖 2. 在联合索引的时候，最左前缀索引和索引下推
- 加索引会不会加锁，在5.6之前，加索引会加MDL，在5.6之后，支持Online DDL, 如果是copy方式，加索引期间，只允许读，不允许更新，如果是inplace，则会在创建临时文件的时候加写锁，然后
变成读锁，支持更新，最后通过记录的rowlog追平数据。Online DDL 一定是inplcae， inplace不一定是online ddl，比如加全文索引和空间索引的时候还是锁表
- 索引失效的场景 1.不符合最左前缀的场景，2 索引字段转换，导致索引的排序失效，比如隐式转换，字符类型转换，运算符，函数 3 全表扫描比索引快 4 or is not null

# mvcc
- 通过undolog 和 readview实现，其中undolog就是在事务中，没此执行一个更新操作，都会记录旧的数据，每个数据都有两个额外的字段，一个是当前事务的id，另一个是指向历史记录的指针。
- readview 在事务开启的时候会记录一个数数组，记录当前事务已经开启但未提交，其中最小值记未低水位，最大值记为高水位，在高水位和低水位之间的，如果在数据中就不可见，如果不在数组中表示已经提交了，可见
- readview 的创建是事务开启后的第一个查询，申请一个事务id
- 一致性读，就是根据事务的id，有最新的记录往前查找到对应的事务id的undolog，undolog值就是对应的事务开启的时候的值
- 快照读，对于insert、update、delete、select for update会读最新的值，并把记录的事务id更新成当前事务的id。
- rowid 如果没有主键的时候，默认补充
- undolog 清除，判断事务已经提交
- rc 每次快照读会生成一个readview rr在事务开启的时候会创建一个快照读，之后不再创建

# 锁
- 全局锁 主要用于备份的时候
- 表锁 MDL
- 行锁 需要的时候才会加锁，事务提交之后才会释放
- 间隙锁 临键锁