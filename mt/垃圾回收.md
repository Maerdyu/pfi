# JVM垃圾回收


## 三个问题

- 怎么确定那些要回收
- 什么时候回收
- 怎么回收

# 怎么确定那些要回收

- 引用计数法和gc root根搜索算法
- 引用计数法的问题，循环引用
- gc root有那些，简单理解就是堆外指向堆内的引用， jvm虚拟机栈帧中应用的对象，方法区的静态引用，JNI引用 启动但未停止的线程， oopMap
- 为什么要stop the world，让虚拟机堆栈不再变化
- 安全点的实现，通过设置一块内存不可读，然后捕获异常，让线程等待
- 对于解释执行来说，每一条字节码之间都会执行一次安全点检测
- 对于即时编译，会在生成机器码的时候插入安全点检查，一般是方法跳转和循环回边 （编译器生成的机器码打乱了原本栈桢上的对象分布状况）

## 垃圾回收算法
- 标记清除 会导致内存随便， 指针碰撞分配不可用，只能查找空闲列表
- 标记整理压缩 会改变栈帧中引用对象的地址，压缩算法的开销
- 复制 以空间换时间 空间利用率低
- 分代收集
- 新生代对象在经历一定复制次数或者survivor空间占用超过50%的时候，复制次数较多的对象会晋身到老年代，大对象也会直接担保分配到老年代
- 卡表 将对分成512字节的小卡，然后标志有指向新生代的脏卡，然后只用扫描脏卡，gc完之后更新脏卡

## 垃圾回收器
- Serial
- ParNew
- Parallel Scavenge
- Serial Old
- ParNew Old
- CMS
- G1

# cms和G1区别
- cms是老年代的并发标记清楚，会造成内存碎片，导致频繁发生full gc。具体原理就是先进行stw，扫描所有的gc root，然后并发扫描所有关连的对象，最后在stw，追平并发期间发生的垃圾对象，然后清理，java9弃用，类似online ddl
- G1 就是作用在青年代和老年代，将对分成很多region，对有gcroot的region进行标记，然后对对有gcroot引用的region标记，其他region可以继续分配对象，然后并发查找对象，标记整理,利用多个cpu优势
