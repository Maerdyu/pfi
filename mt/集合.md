
# ArrayList
- 继承abstractList,基于数组实现
- 实现cloneable Serializable，randomAccess
> 集合中的数据都是transient修饰? 这个表示该字段不进行序列化的,因为序列化会序列化整个数组，包括没有数据的内存空间。通过提供的writeObject readObject提供序列化
- 基于数组实现的线性表，默认大小是10，支持自动扩容，扩容大小是原来的1.5倍
- 添加元素时，如果不指定小标，速度是很快的
- 删除的指定下标的时候，数组需要重组，但是可以通过逻辑删除处理（标记整理）
- 为什么ArrayList不是线程安全的，如果要线程安全要怎么做？因为时间片导致操作不是原子操作，还有数据的可见性问题

# LinkedList
- 实现cloneable Serializable 不支持随机访问，内存空间不是连续分布。
- 基于双向链表实现Node，定义了头指针和尾指针
- 添加元素的时候，只需要改变前面元素的next 后面元素的pre
- 删除元素的时候，判断index是在前部分还是后部分，选择从前还是从后卖弄开始查找
- 遍历的话使用迭代器，比for循环快


# HashMap
- Node数组,其中Node除了key value以外还有一个next,用于解决hash冲突的时候生成链表。
- 默认大小16 负载因子0.75表示数组大小超过总容量的75%出发扩容，扩容每一次扩大一倍。变成红黑树阈值8 变成链表阈值6 使用红黑树的最小数组大小为64
- 添加元素的时候 先判断是不是空，如果是空的resize(), 然后计算hash()对应的index ，对应的数组是空，则new Node 并赋值。如果存在值，需要判断是不是同一个key，如果是同一个key就覆盖。如果是红黑树，新增红黑树节点。如果是7个链表且数组容量大于等于64.就变成红黑树，不大于64就resize()
> (n-1) & hash() 保证分布在数组范围内，h^h>>>16 尽量打乱 hashCode 真正参与运算的低 16 位
- 扩容 在1.7中重新计算hash 然后使用尾插法（并发链表死循环） 在1.8中，不是重新计算hash，只是看原来hash的前一位是1还是0，如果是1就加原数组的大小，是0的话不变，使用尾插法
> hashMap 为什么是线程不安全的？1多线程情况，A线程在put值的时候，cpu时间片耗尽，B线程也put一个和A线程hash冲突的值的时候，A线程回复执行会覆盖B线程的值，这里就延申到多线程的原子性, 可见性 volatile 多核cpu缓存和内存数值不一致，更新到内存并每次从内存取
