# java内存模型
- happen-before 如果操作 X happens-before 操作 Y，那么 X 的结果对于 Y 可见。
- 实现方式：内存屏障  volatile 通过强制刷新内存（cpu的缓存和内存一致）保证读后的内存操作不会重排序到之前，写操作之后的内存操作不会排序到写之前

# synchronized
- 实现方式，通过monitorenter 和monitorexit方式控制，简单理解就是monitor上有一个锁计数器和指向一个指向线程的指针，每次在获取锁的时候，
判断是不是拥有锁的线程，如果是的话就+1，释放就减1，0的话代表没有锁
- wait notify 对象上的方法，wait时表示释放锁，notify需要重新获取锁，
- 非公平锁

# java对象
- markword 包括hash 锁标识，gc标识， 还有指向对象类型的指针
- 实例数据
- 对其填充，可以实现指针压缩（通过偏移量）

# 锁升级
- 00 表示轻量级锁，01表示偏向锁或者无锁，10表示重量级锁，
- 偏向锁，默认为每次同一个线程获取锁，将线程id记录到对象的markword epoch记录偏移锁次数，超过20次之后标记Class，再也会获取偏向锁。java15之后取消偏向锁。
偏向锁的撤销会导致stw，遍历线程查到拥有偏向锁的线程。 启动的时候慢
- 轻量级锁，如果有多个线程在不同时间获取锁的时候，对markword的线程Id进行CAS替换，替换成功则保持偏向锁，如果替换失败则转换成轻量级锁，在栈帧中生成一个锁记录，将markword指向锁记录地址
- 重量级锁，在轻量级锁发生冲突的时候，升级成重量级锁，没有获取到线程会自旋一定次数，然后阻塞。

# AbstractQueuedSynchronizer
- 组成部分，state 标记是否有线程获取，并标记状态，双向链表的同步队列，condition的条件队列
- state是0的时候表示无锁，可以获取锁，当设置成非公平的时候，线程会直接获取锁，没有获取到再尾插法放到队列尾，并标记前一个节点可以被唤醒
- 同一个线程重新获取的时候，state加1，释放的时候减1，直到state为0，每次唤醒都是从头节点开始，如果为取消则从尾向前找
- condition队列实现wait signal，线程调用wait的时候，会放到condition队列，signal的时候重新回到同步队列并重新抢占锁