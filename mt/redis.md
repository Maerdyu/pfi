# 数据类型和数据结构
- 支持String list sortlist hash set
- 对应的数据结构有 String 数组，hash表 压缩数组 跳表 双向链表

# 为什么这么快
- 内存存储和多路复用(非阻塞io)

# 持久化
- AOF 增量记录每次操作记录，fork主线程（不阻塞主线程） 策略是always second no 日志重写
- RBD 生成日志也是可以写的，在更新的时候，生成副本，主线程修改副本，日志生成完之后覆盖
- RBD 和 AOF混用，在两次RBD中间使用aof

# 主从同步
- 第一步从发送psync 主发送fullsync 然后生成rbd同步给从，之后增量通过replication buffer同步
- 使用主从从减少主从同步
- 断开链接会记录偏移量，主会从偏移量记录到一个环形缓冲区，如果没有写满之前恢复，则把缓冲区的数据同步过去，否则需要重新rbd

# 哨兵
- 超过半数确认才能客观确认主库挂
- 主库的选取，先排除掉失联和经常断联的节点，然后按照优先级，同步偏移量，id号选取主库
- 哨兵的功能包括判断主库是否下线，选主库，通知客户端

# 哨兵集群
- 哨兵之间通过主库的发布订阅确认彼此
- 从节点从主库的info信息获取
- 哨兵通知客户端通过哨兵的发布订阅
- 哨兵的谁执行选主通过谁取得超过半数的票

# 集群
- 数据分片  0~16383 2K 集群节点之间消息大小 必须分完
- 实例之间共享hash槽信息，客户端获取后缓冲
- 重定向机制，hash变化的时候，实例返回需要重定向的节点

# 消息队列的三个问题
- 消费顺序的问题，由结果改成增量变化
- 重复消费的问题，全局唯一id
- 消费丢失，先备份再消费

# 内存淘汰
- 有过期时间由根据过期时间删除，随机删除，lru，lfu 没有过期时间只有随机删除，lru lfu 还有就是不删除报错
- lru优化，对数据标记最近一次使用时间，淘汰采用采样
- lfu优化，标记数据的访问次数，淘汰访问次数最少的，访问次数相同则使用时间戳 不是单纯加1 而且由衰减机制

# 和数据不一致问题
- 先删除redis再删数据库，重试，高并发就延迟双删
- 先删除数据库再删除redis 重试

# 雪崩，击穿，穿透
- 雪崩，同一时间失效，增加随机过期，熔断降流
- 击穿，热点数据过期，设置不过期
- 穿透，请求无效数据，对无效数据设置空缓存，布伦过滤器，前端校验